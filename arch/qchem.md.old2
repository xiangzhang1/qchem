Node
===================================================================================


script [axm, meta-axm, state-machine] 
------------------------
our goal is: simplify, separate logic / cleric
map. input: phase, cell, property_wanted {logic [cleric(approximations, engine)]}. output: {property} % wf
map. input: logic (phase, cell, property), cleric (approximations). output: [cleric entity] % gen
map. def. input: -. output: {property}. % class

meta <--> parent: phase, cell, property wanted ==[ child: phase, cell, property wanted --> engine (draw data from)
parent - property_wanted - child - engine - filesystem

axiomatic input. rigorous program. 
key is tree label. save point. one way inheritance.

init -> compute -> inquire on property

ket computes: 
	ket.compute() 
		property_wanted.compute() for phantom
			property_wanted.compute() 
				ket.moonphase() //3:api-finished, 2:api-hang, 1: api-computable, 0: no-api, -1: error
			create Ket(), ket.compute()
		compute_engine.compute() for copy
			self.gen
			self.compute_engine
			self.compute_engine.compute() 
	self.edit(), ket.delete()
		property_wanted.write_(), property_wanted.read_()
ket has properties we can inquire:
		ket.consider()
		
phase.py
	Element, ElementsDict, ELEMENTS, lazyattr, word_wrap
	Ket, KETS
		phase, cell, property_wanted
			* irrelevantly: path, label
		qd, gen, vasp
		compute()
engines.py
	Cell
		name, stoichiometry, nion, nelect, base, coordinates
	Property_wanted: a graphic graph
		nodes[0]: [property_wanted_, , ]. edges[0]: [p_, p_, arrow]
			* irrelevantly: node[1]=path, node[2]=label, edge[0,1] in [property_wanted_, path, label]
			* input_: csv(node) \n\n print(edge)
		compute(), moonphase(), write_()read_(), node(any), prev(any), subset([any])
	Gen: text parser
		mod, kw
		parse_if(), parse_require(), getkw()
		__init__('mod, kw=val',cell)
			engine.gen.conf
	Vasp
		__init__(gen, cell, path)
		moonphase(), compute()
		
	
	
